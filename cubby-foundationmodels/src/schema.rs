use anyhow::{Context, Result};
use serde_json::Value;

/// Trait for types that can be generated by FoundationModels
///
/// Implement this trait for any Rust type that corresponds to a Swift @Generable struct.
pub trait GenerableSchema: Sized + Send + 'static {
    /// Name of the schema (must match Swift struct name)
    fn schema_name() -> &'static str;

    /// Parse from JSON value returned by Swift
    fn from_json(value: Value) -> Result<Self>;

    /// Convert to JSON (for serialization if needed)
    fn to_json(&self) -> Result<Value>;
}

/// PersonInfo schema matching Swift's PersonInfo struct
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PersonInfo {
    pub name: String,
    pub age: i32,
}

impl GenerableSchema for PersonInfo {
    fn schema_name() -> &'static str {
        "PersonInfo"
    }

    fn from_json(v: Value) -> Result<Self> {
        Ok(PersonInfo {
            name: v["name"]
                .as_str()
                .context("missing 'name' field")?
                .to_string(),
            age: v["age"].as_i64().context("missing 'age' field")? as i32,
        })
    }

    fn to_json(&self) -> Result<Value> {
        Ok(serde_json::to_value(self)?)
    }
}

/// ArticleSummary schema - example of a second schema type
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ArticleSummary {
    pub title: String,
    pub summary: String,
    pub key_points: Vec<String>,
}

impl GenerableSchema for ArticleSummary {
    fn schema_name() -> &'static str {
        "ArticleSummary"
    }

    fn from_json(v: Value) -> Result<Self> {
        Ok(ArticleSummary {
            title: v["title"]
                .as_str()
                .context("missing 'title' field")?
                .to_string(),
            summary: v["summary"]
                .as_str()
                .context("missing 'summary' field")?
                .to_string(),
            key_points: v["key_points"]
                .as_array()
                .context("missing 'key_points' array")?
                .iter()
                .filter_map(|v| v.as_str().map(|s| s.to_string()))
                .collect(),
        })
    }

    fn to_json(&self) -> Result<Value> {
        Ok(serde_json::to_value(self)?)
    }
}
