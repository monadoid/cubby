# CLI Guidelines Summary

## Philosophy

### Human-first design
- Design CLI programs primarily for human use rather than just for other programs
- Shed the baggage of machine-first design assumptions from traditional UNIX commands

### Simple parts that work together
- Build small, simple programs with clean interfaces that can be combined
- Use standard conventions (stdin/stdout/stderr, signals, exit codes) for composability
- Support plain text and JSON for piping between commands
- Design for composability without compromising human usability

### Consistency across programs
- Follow existing terminal conventions and patterns where possible
- Break with convention only when it significantly compromises usability
- Make programs intuitive and guessable by following established patterns

### Saying (just) enough
- Avoid both too little information (hanging silently) and too much (overwhelming output)
- Balance clarity with conciseness in all output

### Ease of discovery
- Provide comprehensive help texts with examples
- Suggest next commands and error corrections
- Make functionality discoverable without requiring memorization

### Conversation as the norm
- Design for iterative, conversational interaction patterns
- Support trial-and-error workflows gracefully
- Provide clear intermediate states in multi-step processes
- Confirm dangerous operations before execution

### Robustness
- Handle unexpected input gracefully and feel reliable to users
- Keep users informed about what's happening
- Explain common errors in human terms
- Avoid scary-looking stack traces

### Empathy
- Design with the user's success and enjoyment in mind
- Exceed expectations through thoughtful problem-solving
- Give users the feeling that you're on their side

### Chaos
- Accept that terminal environments are inconsistent
- Break rules intentionally and with clear purpose when necessary
- Balance innovation with adherence to useful conventions

## Guidelines

### The Basics
- Use a command-line argument parsing library for handling args, flags, and help
- Return zero exit code on success, non-zero on failure
- Send primary output to stdout, messaging/errors to stderr

### Help
- Display extensive help text for `-h` and `--help` flags
- Display concise help by default when required arguments are missing
- Show full help for `-h`, `--help`, and `help` subcommand variations
- Provide support path and web documentation links in help text
- Lead help text with examples, especially common complex uses
- Display most common flags and commands first in help
- Use formatting (bold headings) in help text for scannability
- Suggest corrections when users make typos or mistakes
- Display help immediately if expecting piped input but stdin is a terminal

### Documentation
- Provide both web-based and terminal-based documentation
- Consider man pages but make docs accessible via the tool itself
- Link terminal help to web documentation for detailed information

### Output
- Prioritize human-readable output when stdout/stderr is a TTY
- Provide machine-readable output that doesn't break usability
- Use `--plain` flag for plain tabular text compatible with grep/awk
- Use `--json` flag for structured JSON output
- Display brief output on success, avoid completely silent operation
- Tell users when state changes occur and what the new state is
- Make current system state easy to view
- Suggest follow-up commands users should run
- Make actions crossing program boundaries explicit
- Use ASCII art and symbols to increase information density
- Use color intentionally, disable when not in TTY or when requested
- Disable animations when stdout is not a TTY
- Use symbols and emoji sparingly to clarify information
- Avoid developer-only information in default output
- Don't treat stderr like a log file by default
- Use a pager for large text output when in interactive terminal

### Errors
- Catch expected errors and rewrite them for humans
- Maintain high signal-to-noise ratio in error output
- Place most important information at the end where users look first
- Provide debug info and bug report instructions for unexpected errors
- Make bug reporting effortless with pre-populated information

### Arguments and flags
- Prefer flags over positional arguments for clarity
- Provide both short (`-h`) and long (`--help`) versions of flags
- Reserve single-letter flags for commonly used options
- Allow multiple arguments for simple file operations
- Limit different argument types to avoid confusion
- Use standard flag names (`-a/--all`, `-d/--debug`, `-f/--force`, etc.)
- Make defaults work for most users
- Prompt for missing required input
- Never require prompts - always provide flag/argument alternatives
- Confirm dangerous operations with appropriate severity levels
- Support `-` for stdin/stdout in file operations
- Allow special values like "none" for optional flag values
- Make arguments, flags, and subcommands order-independent when possible
- Don't read secrets directly from flags - use files or stdin instead

### Interactivity
- Only prompt when stdin is an interactive terminal (TTY)
- Support `--no-input` flag to disable all interactive elements
- Don't echo password input to terminal
- Always provide clear escape mechanisms (avoid vim-like confusion)
- Ensure Ctrl-C works even during network operations

### Subcommands
- Use subcommands to manage complexity in sufficiently complex tools
- Maintain consistency across subcommands in flags and output
- Use consistent noun-verb or verb-noun ordering for multi-level subcommands
- Avoid ambiguous or similarly-named subcommands
- Choose clear, distinct command names

### Robustness
- Validate all user input early and provide clear error messages
- Show something to user within 100ms for responsiveness
- Display progress indicators for long-running operations
- Include time estimates and animations in progress indicators
- Parallelize operations thoughtfully with clear progress reporting
- Configure reasonable network timeouts
- Make operations recoverable after transient failures
- Design for crash-only operation without required cleanup
- Prepare for misuse and unexpected environments

### Future-proofing
- Keep interface changes additive when possible
- Warn users before making breaking changes
- Allow iteration on human output while keeping machine output stable
- Avoid catch-all subcommands that prevent future expansion
- Don't allow arbitrary abbreviations of subcommands
- Avoid dependencies that create "time bombs" for future operation

### Signals and control characters
- Exit immediately on Ctrl-C (INT signal) with immediate user feedback
- Add timeouts to cleanup operations
- Allow second Ctrl-C to skip lengthy cleanup with clear warning
- Design to handle startup without prior cleanup completion

### Configuration
- Use flags for per-invocation varying config
- Use flags and environment variables for stable but varying config
- Use version-controlled files for project-stable config
- Follow XDG Base Directory Specification for config file locations
- Apply configuration in precedence order: flags → env vars → project config → user config → system config
- Ask consent before modifying non-program configuration
- Prefer creating new config files over appending to existing ones

### Environment variables
- Use environment variables for context-dependent behavior
- Use only uppercase letters, numbers, and underscores in names
- Aim for single-line environment variable values
- Avoid commandeering widely-used environment variable names
- Check standard environment variables (`NO_COLOR`, `DEBUG`, `EDITOR`, etc.)
- Read from `.env` files for project-specific configuration
- Don't use `.env` as substitute for proper config files with complex needs
- Never read secrets from environment variables due to security risks

### Naming
- Choose simple, memorable, but not too generic command names
- Use only lowercase letters and dashes if necessary
- Keep names short but not cryptically brief
- Optimize names for typing ease and hand comfort

### Distribution
- Distribute as single binary when possible
- Use platform native package installers otherwise
- Make uninstallation easy with clear instructions

### Analytics
- Never collect usage/crash data without explicit user consent
- Clearly explain what data is collected and why
- Prefer opt-in over opt-out for data collection
- Consider alternatives like documentation analytics and user communication